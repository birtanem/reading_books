## 도시를 세운다면?
- 도시가 돌아가는 이유는 적절한 추상화와 모듈화 때문.

## 시스템 제작과 시스템 사용을 분리하라
  ```java
    public Service getService(){
      if(service == null)
        service = new MyServiceImpl(...);  //모든 상황에 적합한 기본값일까?
      return service;
    }
  ```
- 시작 단계는 관심사(concern)
- 초기화 지연은 불필요한 부하가 걸리지 않고, 어떤 경우에도 null을 반환하지 않는다.     
  그러나 getService메슫가 MyServiceImpl과 생성자 인수에 명시적으로 의존하며, 의존성을 해결하지 않으면 컴파일이 안된다.
  이는 테스트에도 문제가 되는데 MyServiceImpl이 무거운 객체라면 단위테스트에서 메서드를 호출하기 전 적절한 테스트 전용객체를 service 필드에 할당해야한다.
  그리고 모든 실행 경로도 테스트 해야한다. (if)
  ### Main 분리
    - 생성과 관련한 코드는 모두 main이나 main이 호출하는 모듈로 옮길 것.
    - 애플리케이션은 main이나 객체가 생성되는 과정을 전혀 모른다.
  ### 팩토리
    - 때로는 객체가 생성되는 시점을 애플리케이션이 결정해야 할 때 factory객체를 만들어 전달하자.
    - 자세한 구현을 숨기려면 Abstract factory패턴을 사용~!
  ### 의존성 주입
    - 사용과 제작을 분리하는 강력한 메커니즘으로 제어역전을 의존성 관리에 적용한 것.
    ```java
      MyService myService = (MyService)(jndiContext.lookup("NameOfMyService"));
    ```
    - 진정한 의종성 주입은 완전히 수동적이다. setter메서드나 생성자 인수를 제공하여 의존성을 주입한다.
  
## 확장
  - 처음부터 올바르게 시스템을 만들수 있다는 믿음은 미신이다.
  - 오늘 주어진 사용자 스토리에 맞춰 시스템을 구현해야 한다. => 반복적이고 점진적인 애자일 방식의 핵심.
  - EJB2구조의 문제점
    - 비즈니스 로직이 EJB2애플리케이션 컨테이너에 강하게 결합되어 있다. 클래스 생성 시 컨테이너에서 파생해야 하고, 다양한 메서드를 구현해야 한다.
    - 독자적 단위테스트가 어렵다.
    - 상속도 안되는 불필요한 DTO를 작성해야 한다.
  ### 횡단(cross-cutting)관심사
    - 원론적으로는 모듈화, 캡슐화 된 방식으로 구상 될 수 있지만 실제로는 코드의 객체에 존재하기 쉬운 부분들

## cross cutting 관심사를 해결하기 위한 세가지 메커니즘
  ### 자바 프록시
    - 단순한 상황에 적합하다. 
    - 개별 객체나 클래스에서 메서드 호출을 감싸는 경우.
    - 프록시를 사용하면 깨끗한 코드를 작성하기 어렵다. 코드의 양과 크기가 크다.
    
  ### 순수 자바 AOP프레임워크
    - 프록시의 단점은 AOP 프레임워크를 통해 해결이 된다.
    - 스프링은 비즈니스 로직을 POJO로구현해 도메인에 초점을 맞춘다. 따라서 테스트가 쉽고 간단하며 의존성이 줄어든다.
    - xml은 읽기 어렵지만 프록시보다는 쉽다.
    - EJB3은 깨끗한 코드를 작성하게 하고 테스트 및 유지보수가 쉬워졌다.
  ### AspectJ 관점
    - 언어 차원에서 관점을 모듈화 구성으로 지원하는 자바 언어 확장이다.
    - 강력하지만 새 도구를 사용하고 새 언어와 문법을 익혀야 한다.

## 테스트 주도 시스템 아키텍쳐 구축
  - 도메인 논리를 POJO로 작성이 가능하다면, 진정한 테스트 주도 아키텍쳐 구축이 가능해진다.
  > 최선의 시스템 구조는 각기 POJO(또는 다른) 객체로 구현되는 모듈화된 관심사의 영역(도메인)으로 구성된다. 서로 다른 영역은 최소한의 영향을 미치는 관점이나 유사한 도구를 사용해 통합해야한다. 이런 구조 또한 코드와 마찬가지로 테스트 주도 기법을 적용할 수 있다.

## 의사결정을 최적화 하라
  - 모듈을 나누고 관심사를 분리하면 지엽적인 관리과 결정이 가능해진다.
  > 모듈로 분리한 POJO시스템은 기민함을 제공한다. 이로인해 결정의 복잡성도 줄어든다.

## 명백한 가치가 있을 때 표준을 현명하게 사용하라.
  > 표준을 사용하면 재사용성, 캡슐화, 모듈화하기 쉽다. 때론 표준을 만드는데 시간이 오래 걸리면 원래의 목적을 잊어버리기도 한다.

## 시스템은 도메인 특화 언어가 필요하다.
 - DSL(Domain-Specific Language)은 간단한 스크립트 언어나 표준 언어로 구현한 API
 - DSL로 짠 코드는 구조적인 산문처럼 읽히며 의사소통 간극을 좁혀준다.
 - 효과적으로 사용시 추상화 수준을 코드 관용구나 디자인 패턴 이상으로 끌어 올려 개발자의 의도를 적절히 표현할 수 있다.

## 결론
  - 시스템은 깨끗해야 한다.
  - 도메인 논리가 흐려지면 제품 품질이 떨어진다.
  - 기민성이 떨어지면 생산성이 낮아져 TDD가 제공하는 장점이 사라진다.
  - 추상화 단계에서는 의도는 명확히 표현해야 한다. 그러기 위해선 POJO를 작성하고 적절한 메커니즘을 사용해 각 구현을 분리해야한다.






  
